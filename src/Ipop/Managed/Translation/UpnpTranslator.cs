/*
Copyright (C) 2010  David Wolinsky <davidiw@ufl.edu>, University of Florida
                    Pierre St Juste <ptony82@ufl.edu>, University of Florida
                    Benjamin Woodruff <odetopi.e@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

using System;
using System.Text;
using Brunet.Util;
using Ipop;
using NetworkPackets;
using NetworkPackets.Dns;
using System.Collections;
using Brunet.Applications;

#if ManagedIpopNodeTranslatorsNUNIT
using NUnit.Framework;
#endif

namespace Ipop.Managed.Translation {
  public class SsdpTranslator : ProtocolTranslator<UdpPacket> {
    
    public SsdpTranslator(MemBlock local_ip) : base(local_ip) { }
    
    public override bool MatchesProtocol(UdpPacket packet) {
			//Console.WriteLine("This packet is UPnP packet: {0}, {1}", packet.DestinationPort, packet.SourcePort);
      return packet.DestinationPort == 1900 || packet.SourcePort == 1900;
    }
    
    public override UdpPacket Translate(UdpPacket packet,
                                        MemBlock source_ip,
                                        MemBlock old_source_ip,
                                        MemBlock old_dest_ip) {
      // SSDP runs on 1900
      string s_source_ip = Utils.MemBlockToString(source_ip, '.');
      //Console.WriteLine("    Location --> " + s_source_ip);
      return UPnPTranslate(packet, s_source_ip);
    }
    
    /// <summary>
    /// Finds the oldIP in the packet in the LOCATION section, and replaces it
    /// with the new one. Will display a warning if the packet is not HTTP 1.1
    /// or below. It the major version is equal to 1, it will attempt to
    /// translate it anyways, otherwise, it will just pass through.
    /// </summary>
    /// <param name="oldIP">The old IP address to be replaced</param>
    /// <param name="newIP">The new IP address to replace the old one</param>
    /// <returns>Returns the translated UDP packet</returns>
    public static UdpPacket UPnPTranslate(UdpPacket udpp, string newIP) {
      try {
      	string rawData = udpp.Payload.GetString(System.Text.Encoding.UTF8);
      	//Console.WriteLine("OLD PACKET:");
      	//Console.WriteLine(rawData+"\n");
      	StringBuilder data = new StringBuilder(rawData);
      	int httpDataStart = rawData.IndexOf("HTTP/")+5;
      	if(httpDataStart < 5) { 
      		return new UdpPacket(udpp.SourcePort, udpp.DestinationPort, MemBlock.Reference(Encoding.UTF8.GetBytes(data.ToString())));
				} //not an http packet, don't
        	                                     //translate
      	int httpPeriod = rawData.IndexOf('.', httpDataStart);
      	int majorVersion = Int32.Parse(rawData.Substring(
        	                              httpDataStart, httpPeriod-httpDataStart
                                    ));
				//Console.WriteLine("majorVersion: {0}", majorVersion);
      	if(majorVersion != 1) {
        	ProtocolLog.WriteIf(
          	TranslateLog.VersionMismatch,
          	"Incompatable major version of an HTTP packet found: " +
            	majorVersion + ". Not performing translation on packet."
        	);
        	//Console.WriteLine("Bad major http version");
      		return new UdpPacket(udpp.SourcePort, udpp.DestinationPort, MemBlock.Reference(Encoding.UTF8.GetBytes(data.ToString())));
      	}
      	// TODO: This code is really slow, we need some regex up in here
      	//       also, the double Math.Min stuff is really hackish. Why doesn't
      	//       C# use varible length arguments for stuff like this? It can do it
      	int spaceIndex = rawData.IndexOf(' ', httpPeriod)+1; //rawData.IndexOf(' ', httpPeriod) returned -1
      	int newLineIndex = rawData.IndexOf("\r\n", httpPeriod)+2;
      	if(spaceIndex < newLineIndex && spaceIndex > 0) {
        	httpDataStart = spaceIndex;
      	} else if(newLineIndex < spaceIndex && newLineIndex > 1) {
        	httpDataStart = newLineIndex;
      	} else { 
					//return udpp; //contains no data!!!
      	  return new UdpPacket(udpp.SourcePort, udpp.DestinationPort, MemBlock.Reference(Encoding.UTF8.GetBytes(data.ToString())));
				}
      
      	int minorVersion = Int32.Parse(rawData.Substring(
        	httpPeriod+1, httpDataStart-httpPeriod-2
      	));
      	if(minorVersion > 1) {
        	ProtocolLog.WriteIf(
          	TranslateLog.VersionMismatch,
          	"Possibly incompatable minor version of an HTTP packet found: " +
            	majorVersion + "." + minorVersion +
            	", attempting to translate anyways."
        	);
      	}
      	//Console.WriteLine("HTTP Version: " + majorVersion + "." + minorVersion);
      	int sipLocation = rawData.IndexOf(
        	"://",
        	rawData.IndexOf("\r\nLOCATION: ", httpDataStart) + 12
      	) + 3;
      	if(sipLocation < 3) { 
      		return new UdpPacket(udpp.SourcePort, udpp.DestinationPort, MemBlock.Reference(Encoding.UTF8.GetBytes(data.ToString())));
				} //doesn't contain LOCATION, don't
      	                                     //translate
      	int eipLocation = Math.Min(
        	rawData.IndexOf(':', sipLocation), // specifies a port
        	rawData.IndexOf('/', sipLocation)  // doesn't specify a port
      	);
      	data.Remove(sipLocation, eipLocation-sipLocation);
      	data.Insert(sipLocation, newIP);
      	//Console.WriteLine("NEW PACKET:");
      	//Console.WriteLine(data.ToString());
      	return new UdpPacket(udpp.SourcePort, udpp.DestinationPort, MemBlock.Reference(Encoding.UTF8.GetBytes(data.ToString())));
      } catch(Exception ex) {
        Console.WriteLine("EXCEPTION!!! " + ex.ToString());
        return udpp;
      }
    }
    /* EXAMPLE HTTP/1.1 PACKET: Note: each line ends with \r\n
    HTTP/1.1 200 OK
    USN: uuid:38bbdf81-626f-43c4-95ed-b6ec9c500fc4
    SERVER: Linux,2.6.32-21-generic,UPnP/1.0,Coherence UPnP framework,0.6.6.2
    last-seen: 1277391811.0
    EXT: 
    LOCATION: http://10.227.56.240:1900/38bbdf81-626f-43c4-95ed-b6ec9c500fc4/...
                                                            ...description-2.xml
    CACHE-CONTROL: max-age=1800
    ST: uuid:38bbdf81-626f-43c4-95ed-b6ec9c500fc4
    DATE: Thu, 24 Jun 2010 15:04:14 GMT
    */
  }
  
  #if ManagedIpopNodeTranslatorsNUNIT
  [TestFixture]
  public class SsdpTester {
    [Test]
    public void Test() {
      
      //Define packets
      UdpPacket[] udpp = new UdpPacket[]{
      
      new UdpPacket(1900, 1900, MemBlock.Reference(new byte[] {
        0x48, 0x54, 0x54, 0x50, 0x2F, 0x31, 0x2E, 0x31, 0x20, 0x32, 0x30, 0x30,
        0x20, 0x4F, 0x4B, 0x0D, 0x0A, 0x55, 0x53, 0x4E, 0x3A, 0x20, 0x75, 0x75,
        0x69, 0x64, 0x3A, 0x35, 0x65, 0x63, 0x35, 0x31, 0x32, 0x32, 0x64, 0x2D,
        0x63, 0x31, 0x30, 0x35, 0x2D, 0x34, 0x62, 0x32, 0x35, 0x2D, 0x38, 0x38,
        0x37, 0x62, 0x2D, 0x64, 0x66, 0x37, 0x39, 0x61, 0x64, 0x32, 0x66, 0x64,
        0x30, 0x66, 0x31, 0x3A, 0x3A, 0x75, 0x72, 0x6E, 0x3A, 0x73, 0x63, 0x68,
        0x65, 0x6D, 0x61, 0x73, 0x2D, 0x75, 0x70, 0x6E, 0x70, 0x2D, 0x6F, 0x72,
        0x67, 0x3A, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x3A, 0x4D, 0x65, 0x64,
        0x69, 0x61, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x3A, 0x31, 0x0D, 0x0A,
        0x53, 0x45, 0x52, 0x56, 0x45, 0x52, 0x3A, 0x20, 0x4C, 0x69, 0x6E, 0x75,
        0x78, 0x2C, 0x32, 0x2E, 0x36, 0x2E, 0x33, 0x32, 0x2D, 0x32, 0x31, 0x2D,
        0x67, 0x65, 0x6E, 0x65, 0x72, 0x69, 0x63, 0x2C, 0x55, 0x50, 0x6E, 0x50,
        0x2F, 0x31, 0x2E, 0x30, 0x2C, 0x43, 0x6F, 0x68, 0x65, 0x72, 0x65, 0x6E,
        0x63, 0x65, 0x20, 0x55, 0x50, 0x6E, 0x50, 0x20, 0x66, 0x72, 0x61, 0x6D,
        0x65, 0x77, 0x6F, 0x72, 0x6B, 0x2C, 0x30, 0x2E, 0x36, 0x2E, 0x36, 0x2E,
        0x32, 0x0D, 0x0A, 0x6C, 0x61, 0x73, 0x74, 0x2D, 0x73, 0x65, 0x65, 0x6E,
        0x3A, 0x20, 0x31, 0x32, 0x37, 0x37, 0x33, 0x39, 0x31, 0x36, 0x38, 0x38,
        0x2E, 0x36, 0x36, 0x0D, 0x0A, 0x45, 0x58, 0x54, 0x3A, 0x20, 0x0D, 0x0A,
        0x4C, 0x4F, 0x43, 0x41, 0x54, 0x49, 0x4F, 0x4E, 0x3A, 0x20, 0x68, 0x74,
        0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x31, 0x30, 0x2E, 0x32, 0x32, 0x37, 0x2E,
        0x35, 0x36, 0x2E, 0x32, 0x34, 0x30, 0x3A, 0x31, 0x39, 0x30, 0x30, 0x2F,
        0x35, 0x65, 0x63, 0x35, 0x31, 0x32, 0x32, 0x64, 0x2D, 0x63, 0x31, 0x30,
        0x35, 0x2D, 0x34, 0x62, 0x32, 0x35, 0x2D, 0x38, 0x38, 0x37, 0x62, 0x2D,
        0x64, 0x66, 0x37, 0x39, 0x61, 0x64, 0x32, 0x66, 0x64, 0x30, 0x66, 0x31,
        0x2F, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6F, 0x6E,
        0x2D, 0x31, 0x2E, 0x78, 0x6D, 0x6C, 0x0D, 0x0A, 0x43, 0x41, 0x43, 0x48,
        0x45, 0x2D, 0x43, 0x4F, 0x4E, 0x54, 0x52, 0x4F, 0x4C, 0x3A, 0x20, 0x6D,
        0x61, 0x78, 0x2D, 0x61, 0x67, 0x65, 0x3D, 0x31, 0x38, 0x30, 0x30, 0x0D,
        0x0A, 0x53, 0x54, 0x3A, 0x20, 0x75, 0x72, 0x6E, 0x3A, 0x73, 0x63, 0x68,
        0x65, 0x6D, 0x61, 0x73, 0x2D, 0x75, 0x70, 0x6E, 0x70, 0x2D, 0x6F, 0x72,
        0x67, 0x3A, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x3A, 0x4D, 0x65, 0x64,
        0x69, 0x61, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x3A, 0x31, 0x0D, 0x0A,
        0x44, 0x41, 0x54, 0x45, 0x3A, 0x20, 0x54, 0x68, 0x75, 0x2C, 0x20, 0x32,
        0x34, 0x20, 0x4A, 0x75, 0x6E, 0x20, 0x32, 0x30, 0x31, 0x30, 0x20, 0x31,
        0x35, 0x3A, 0x30, 0x34, 0x3A, 0x30, 0x36, 0x20, 0x47, 0x4D, 0x54, 0x0D,
        0x0A, 0x0D, 0x0A
      })),
      /*
       * HTTP/1.1 200 OK
       * USN: uuid:5ec5122d-c105-4b25-887b-df79ad2fd0f1::urn:...
       *                                ...schemas-upnp-org:device:MediaServer:1
       * SERVER: Linux,2.6.32-21-...
       *                    ...generic,UPnP/1.0,Coherence UPnP framework,0.6.6.2
       * last-seen: 1277391688.66
       * EXT: 
       * LOCATION: http://10.227.56.240:1900/5ec5122d-c105-4b25-887b-...
       *                                       ...df79ad2fd0f1/description-1.xml
       * CACHE-CONTROL: max-age=1800
       * ST: urn:schemas-upnp-org:device:MediaServer:1
       * DATE: Thu, 24 Jun 2010 15:04:06 GMT
      */
      new UdpPacket(1900, 1900, MemBlock.Reference(new byte[] {
        0x4e, 0x4f, 0x54, 0x49, 0x46, 0x59, 0x20, 0x2a, 0x20, 0x48, 0x54, 0x54,
        0x50, 0x2f, 0x31, 0x2e, 0x31, 0x0d, 0x0a, 0x43, 0x41, 0x43, 0x48, 0x45,
        0x2d, 0x43, 0x4f, 0x4e, 0x54, 0x52, 0x4f, 0x4c, 0x3a, 0x20, 0x6d, 0x61,
        0x78, 0x2d, 0x61, 0x67, 0x65, 0x3d, 0x31, 0x38, 0x30, 0x30, 0x0d, 0x0a,
        0x4c, 0x4f, 0x43, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x3a, 0x20, 0x68, 0x74,
        0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x31, 0x30, 0x2e, 0x30, 0x2e, 0x32, 0x2e,
        0x31, 0x35, 0x3a, 0x38, 0x30, 0x38, 0x31, 0x2f, 0x75, 0x70, 0x6e, 0x70,
        0x2f, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2f, 0x36, 0x31, 0x64, 0x62,
        0x31, 0x36, 0x35, 0x36, 0x2d, 0x38, 0x34, 0x33, 0x31, 0x2d, 0x61, 0x62,
        0x38, 0x63, 0x2d, 0x66, 0x66, 0x66, 0x66, 0x2d, 0x66, 0x66, 0x66, 0x66,
        0x63, 0x31, 0x36, 0x32, 0x63, 0x61, 0x65, 0x39, 0x2f, 0x64, 0x65, 0x73,
        0x63, 0x2e, 0x78, 0x6d, 0x6c, 0x0d, 0x0a, 0x53, 0x45, 0x52, 0x56, 0x45,
        0x52, 0x3a, 0x20, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x2f, 0x32, 0x2e, 0x36,
        0x2e, 0x33, 0x32, 0x2d, 0x32, 0x31, 0x2d, 0x67, 0x65, 0x6e, 0x65, 0x72,
        0x69, 0x63, 0x20, 0x55, 0x50, 0x6e, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x20,
        0x54, 0x65, 0x6c, 0x65, 0x61, 0x6c, 0x2d, 0x43, 0x6c, 0x69, 0x6e, 0x67,
        0x2f, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x48, 0x4f, 0x53, 0x54, 0x3a, 0x20,
        0x32, 0x33, 0x39, 0x2e, 0x32, 0x35, 0x35, 0x2e, 0x32, 0x35, 0x35, 0x2e,
        0x32, 0x35, 0x30, 0x3a, 0x31, 0x39, 0x30, 0x30, 0x0d, 0x0a, 0x4e, 0x54,
        0x53, 0x3a, 0x20, 0x73, 0x73, 0x64, 0x70, 0x3a, 0x61, 0x6c, 0x69, 0x76,
        0x65, 0x0d, 0x0a, 0x4e, 0x54, 0x3a, 0x20, 0x75, 0x72, 0x6e, 0x3a, 0x73,
        0x63, 0x68, 0x65, 0x6d, 0x61, 0x73, 0x2d, 0x70, 0x69, 0x70, 0x65, 0x65,
        0x70, 0x3a, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x3a, 0x55, 0x50,
        0x6e, 0x50, 0x54, 0x65, 0x73, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72,
        0x3a, 0x31, 0x0d, 0x0a, 0x55, 0x53, 0x4e, 0x3a, 0x20, 0x75, 0x75, 0x69,
        0x64, 0x3a, 0x36, 0x31, 0x64, 0x62, 0x31, 0x36, 0x35, 0x36, 0x2d, 0x38,
        0x34, 0x33, 0x31, 0x2d, 0x61, 0x62, 0x38, 0x63, 0x2d, 0x66, 0x66, 0x66,
        0x66, 0x2d, 0x66, 0x66, 0x66, 0x66, 0x63, 0x31, 0x36, 0x32, 0x63, 0x61,
        0x65, 0x39, 0x3a, 0x3a, 0x75, 0x72, 0x6e, 0x3a, 0x73, 0x63, 0x68, 0x65,
        0x6d, 0x61, 0x73, 0x2d, 0x70, 0x69, 0x70, 0x65, 0x65, 0x70, 0x3a, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x3a, 0x55, 0x50, 0x6e, 0x50, 0x54,
        0x65, 0x73, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x3a, 0x31
      }))
      /*
       * NOTIFY * HTTP/1.1
       * CACHE-CONTROL: max-age=1800
       * LOCATION: http://10.0.2.15:8081/upnp/device/...
       *                        ...61db1656-8431-ab8c-ffff-ffffc162cae9/desc.xml
       * SERVER: Linux/2.6.32-21-generic UPnP/1.0 Teleal-Cling/1.0
       * HOST: 239.255.255.250:1900
       * NTS: ssdp:alive
       * NT: urn:schemas-pipeep:service:UPnPTestServer:1
       * USN: uuid:61db1656-8431-ab8c-ffff-ffffc162cae9::urn:schemas-pipeep:...
       *                                             ...service:UPnPTestServer:1
       */
      };
      byte[] shouldbe = new byte[] {0x33, 0x31, 0x2E, 0x34, 0x2E, 0x31, 0x35,
                                    0x39, 0x2E, 0x32, 0x36, 0x35};//31.4.159.265
      int[] offset = new int[] {0xE9, 0x41};
      for(int k = 0; k < udpp.Length; ++k) {
        byte[] translated = SsdpTranslator.
                            UPnPTranslate(udpp[k], "31.4.159.265").Payload;
        for(int i = 0; i < shouldbe.Length; ++i) {
          Assert.AreEqual(shouldbe[i], translated[i+offset[k]],
            "Mismatch at byte " + i +
            " (offset " + offset[k] + ", " + i + "+" + offset[k] + "= " +
            (i+offset[k]) + ")"
          );
        }
      }
    }
  }
  #endif
}
